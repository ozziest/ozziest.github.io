I"<p><a href="https://pixabay.com/en/books-pages-story-stories-notes-1245690/" target="_blank">
    <img src="/images/posts/notes.jpg" class="center" />
</a></p>

<blockquote>
  <p>Bu bir kendime not yazısıdır. Daha sonradan unutma ihtimalime karşın kendimce notlar alıyorum.</p>
</blockquote>

<p>Mikro servisler birbirleriyle çalışan küçük, otonom yapılardır. Peki “Ne kadar küçük?” soruna cevap olarak Jon Eaves diyor ki: <strong><em>“Bir mikroservis iki hafta içerisinde yeniden yazılabilir bir şey olmalıdır. Bir diğer basma kalıp düşünceye göre; Yeterince küçük olması gerektiğinde daha küçük değil.”</em></strong></p>

<ul>
  <li>Teknoloji Çeşitliliği
    <ul>
      <li>Tüm microservisler farklı teknolojiler kullanılarak geliştirilebilir.</li>
      <li>İşe uygun olan teknolojiler seçilebilir.</li>
      <li>Yeni bir teknoloji denemek istediğimiz, sadece düşük riskli bir microservice üzerinde bu teknolojiyi deneyebilir ve sonuçlarını gördükten sonra kullanma ya da kullanmama kararı alabilirsiniz.</li>
      <li>Monolithic uygulamalarda yeni bir teknoloji denemesi pek mümkün olmaz ve zamanla sistem bakım maliyetleri artmaya başlar.</li>
    </ul>
  </li>
  <li>Esneklik
    <ul>
      <li>Eğer bir microservice patlarsa, diğer bölümler çalışmalarına devam edebilirler.</li>
      <li>Eğer monolithic bir servis patlarsa, tüm sistem patlar. Biz de bunun olmaması için birden fazla makine ile hatayı tolere etmeye çalışırız.</li>
    </ul>
  </li>
  <li>Ölçeklenebilirlik:
    <ul>
      <li>Monolithic uygulamalarda her şeyi hep birlikte ölçeklemek zorundasınız.</li>
      <li>Microservice mimarisinde, sadece ihtiyacı olan bölümleri kendi içerisinde ölçekleyebilirsiniz.</li>
    </ul>
  </li>
  <li>Yayınlama
    <ul>
      <li>Monolithic uygulamalarda bir satır değişiklik nedeniyle tüm sistemin yayınlanması (deployment) gerekir. Bu tüm sistemin testlerinin tekrardan çalıştırılması, tüm farklı makinalarda yer alan uygulamaların güncellenmesi vs. gibi oldukça uzun bir sürece maal olabilir.</li>
      <li>Tüm uygulamanın aynı anda güncellenmesi oldukça büyük bir riski de beraberinde getirir.</li>
      <li>Microservislerde sadece tek bir mikroservisi geri kalan yapıdan tamamen bağımsız olarak güncelleyebiliriz. Böylece risk azalmış olur. Güncellenen mikroserviste bir hata varsa bile, sadece o mikroservisin (örneğin fotoğraf servisi) işlevleri duracağından (sistemin geri kalanı çalışmaya devam edeceğinden) sorunumuz daha az olacaktır.</li>
    </ul>
  </li>
  <li>Organizasyonel İşbirliği
    <ul>
      <li>Takımlar ve codebase büyüdükçe hatalar çoğalma eğilimindedir.</li>
      <li>Aynı proje üzerinde çalışan büyük bir takım sürekli bir birini rahatsız etmek zorunda kalır.</li>
      <li>Bu nedenlerle küçük takımlar daha üretkendir.</li>
      <li>Microservisler bize daha küçük takım ve codebase avantajı sağlarlar.</li>
    </ul>
  </li>
  <li>Değiştirilebilirlik
    <ul>
      <li>Eğer büyük bir organizasyonun parçasıysanız, yıllar önceden kalma ama hala çalışan bir uygulamayla karşılaşabilirsiniz. Uygulamalanın zamanı çoktan dolmuştur ama kimse ona dokunmak istemez çünkü çok büyük ve risklidir.</li>
      <li>Microservislerin değiştirilmesi kolay olduğundan (2 haftada yeniden yazma süresi) gerekirse tamamen baştan yazabilirsiniz. Bu nedenle riskleri azdır.</li>
      <li>Ne sıklıkla bir gün içinde 100 satırdan daha fazla kodu silmenize rağmen içinizde kuşku olmadan gününüze devam edebilirdiniz?</li>
      <li>Microservislerle çalışırken yeniden yazma ya da değiştirilebilme bariyerleri monolithic uygulamalara göre oldukça azdır.</li>
    </ul>
  </li>
</ul>
:ET