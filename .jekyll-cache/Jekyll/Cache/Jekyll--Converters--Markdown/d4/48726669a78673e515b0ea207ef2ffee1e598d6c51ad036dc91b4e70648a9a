I"{<p><a href="https://pixabay.com/en/books-pages-story-stories-notes-1245690/" target="_blank">
    <img src="/images/posts/notes.jpg" class="center" />
</a></p>

<blockquote>
  <p>Bu bir kendime not yazısıdır. Daha sonradan unutma ihtimalime karşın kendimce notlar alıyorum.</p>
</blockquote>

<p>Her ne kadar <strong>Closure</strong> kelimesinin <strong>Kaplam</strong> olarak çevirilerine daha önce denk gelmiş olsam da, açıkçası bu kelimeyi tam olarak kendi yazılım lügatımıza aktarabileceğimizi sanmıyorum. [1] Çeviri yönünden ele alındığında oldukça zor bir kelime ve belki de bu yüzden bir çok farklı kaynaktan tam olarak anlamaya çalıştığım bir yapı oldu.</p>

<p>Çeviri tartışmasını bir yana bırakırsak ve nedir bu <strong>Closure</strong> irdelemek istersek şöyle bir cümle kurabiliriz;</p>

<blockquote>
  <p>JavaScript dünyasında genellikle olay yakalayıcılarda (event handler) ve <strong><em>callback</em></strong>‘lerde <strong>veri mahremiyeti</strong> amacıyla <strong><em>Closure</em></strong> yapıları kullanıyor. [2]</p>
</blockquote>

<p>Bu noktada <strong><em>“JavaScript’de neyin mahremiyetinden bahsediyoruz?”</em></strong> dediğinizi duyar gibiyim. Bu nedenle biraz kod görelim.</p>

<h3 id="veri-mahremiyeti">Veri Mahremiyeti</h3>

<pre><code class="language-js">
var User = (name) =&gt; {
    
    return {
        get: () =&gt; name,
        getFullname: (surname) =&gt; name + surname
    };

};

var john = User("John");

console.log(john.name);  // undefined
console.log(john.get()); // John
</code></pre>

<p>Burada oluşturduğumuz <code class="language-plaintext highlighter-rouge">User</code> isimli objemiz <code class="language-plaintext highlighter-rouge">name</code> isimli bir parametre alıyor. Ancak bu name <strong><em>Closure</em></strong> sayesinde dışarıdan ulaşılabilir değil. Bu nedenle <code class="language-plaintext highlighter-rouge">name</code> değişkeni üzerinden veriyi doğrudan almaya çalıştığımızda geriye <strong><em>undefined</em></strong> dönüyor. Veriye ulaşabilmemiz mümkün olmadığı için değiştirebilmemiz de mümkün olmuyor. Bu nedenle <code class="language-plaintext highlighter-rouge">User</code> objesine bağlı ve dışarıya açılan (bizim ulaşabileceğimiz) bir <code class="language-plaintext highlighter-rouge">get</code> fonksiyonu oluşturuyoruz. Bu fonksiyonun özelliği kendi kapsamının (scope) daha üzerindeki kapsama da (User kapsamına) ulaşabilmesi. Böylelikle sakladığımız veriyi, kendi yazdığımız fonksiyonlarla dilersek dışarı açabiliyoruz.</p>

<p>Bu Closure kullanımı veri mahremiyeti amacıyla kullanım şeklini temsil ediyor.</p>

<h3 id="paketleme">Paketleme</h3>

<p><strong><em>Paketleme</em></strong> kelimesi benim uydurduğum (5 dakika evvel) bir kavram. Ancak anlatacağım yapının da genel geçer bir adını bulamadım. Yine öncelikle örneği gösterecek, sonra açıklamasını yapacağım.</p>

<pre><code class="language-js">
const message = (text) =&gt; () =&gt; text;
const errorMessage = message("An error occurred!");
console.log(errorMessage()); // An error occurred!
</code></pre>

<p>Buradaki örneğimizde genel bir <code class="language-plaintext highlighter-rouge">message</code> sabiti oluşturuyoruz. Bu sabiti dışarıdan <code class="language-plaintext highlighter-rouge">text</code> isimli parametreye bir veri göndererek çağırdığımızda sonuç olarak bize bir <strong>fonksiyon</strong> gönderiyor.</p>

<p>Örnekteki amacımız; sabit ve her yerde kullandığımız bir mesajı fonksiyonlaştırmak. 2. satırda elde ettiğimiz <code class="language-plaintext highlighter-rouge">errorMessage</code> aslında bir fonksiyon ve içerisindeki mesajımız dışarıdan değiştirilemiyor. Fonksiyonu çağırdığımızda ise içerisinde artık değişmez olarak duran mesajımız geriye dönüyor.</p>

<h3 id="ön-çağırım">Ön Çağırım</h3>

<p>Herhangi bir işi gerçekleştirmek üzere kullandığımız bir fonksiyonun olduğunu varsayalım. Uygulamanızın her yerinden çağırdığınız bu fonksiyona çoğu zaman bazı parametreleri sabit olarak kullanarak çağırıyoruz. Böyle bir durumlarda aşağıdaki yapıyı kullanabiliriz;</p>

<pre><code class="language-js">
const partialApply = (fn, ...fixedArgs) =&gt; {
    return function (...otherArgs) {
        return fn.apply(this, fixedArgs.concat(otherArgs));
    };
};

const add = (a, b) =&gt; a + b;
const add10 = partialApply(add, 10);

console.log(add10(5));
</code></pre>

<p>Burada yer alan <code class="language-plaintext highlighter-rouge">partialApply</code> fonksiyonu ilk parametre olak bir başka fonksiyonu alıyor ve devamında dinamik olarak birden fazla parametre gönderilmesine izin veriyor. Sonuç olarak ise geriye bir başka fonskiyon döndürüyor. Bu geriye gönderilen fonksiyon çağırıldığında ise, ilk etapta gönderilen fonksiyon, ilk ve ikinci çağırımda gönderilen parametrelerle birlikte çağırılıyor. Böylece asıl fonksiyonumuz için bir kolay çağırım fonksiyonu elde etmiş oluyoruz. Çok mu karışık? Biraz da çalışma anını adım adım inceleyelim.</p>

<p><code class="language-plaintext highlighter-rouge">const add = (a, b) =&gt; a + b</code> satırında yer alan <code class="language-plaintext highlighter-rouge">add</code> fonksiyonu bizim asıl fonksiyonumuz ve iki parametre alıyor. Bir alt satırda yer alan <code class="language-plaintext highlighter-rouge">partialApply(add, 10)</code> çağırımımızdan geriye bir fonksiyon geliyor, biz bu fonksiyonu <code class="language-plaintext highlighter-rouge">add10</code> sabiti içerisinde muhafaza ediyoruz. Son satırda <code class="language-plaintext highlighter-rouge">add10(5)</code> şeklinde elimize gelen bu en son fonksiyonu çağırıyoruz.</p>

<p>Bu kodla birlikte <code class="language-plaintext highlighter-rouge">partialApply</code>den bize gelen ve <code class="language-plaintext highlighter-rouge">add10</code> içerisinde tuttuğumuz fonksiyonı çalıştırmış oluyoruz. Bu fonksiyon içerisinde ilk etapta gönderdiğimiz <code class="language-plaintext highlighter-rouge">add</code> fonksiyonunu, ilk parametreler ve son parametrelerle birlikte çalıştırmış oluyoruz.</p>

<p>Buradaki amacımız şu; sürekli 10 ile bir sayısı toplamak istediğimizde, 10 ile toplama işlemini yapacak ama aslında gerçek toplama işlemini fonksiyonunu kullanan bir fonksiyon oluşturmuş oluyoruz. Her seferinde <code class="language-plaintext highlighter-rouge">add(10, 5)</code> yazmak yerine <code class="language-plaintext highlighter-rouge">add10(5)</code> yazarak aynı işi yapmış oluyoruz.</p>

<h3 id="sonuç">Sonuç</h3>

<p>Şuan fıkrasına gülünmeyen adam gibiyim belki ama bu benim cehaletimden kaynaklanıyor da olabilir. Bu bir <strong><em>kendime not</em></strong> yazısı olmasına rağmen neden gerek olduğunu anlatmaya çalışacağım.</p>

<p>Buradaki örnekler basit örnekler ve öğrenmeyi kolay kılması açısından kasıtlı olarak basit seçildiler. Ancak gerçek uygulamalarda işler karışabiliyor ve siz bazı verilerin bazı yerlerden erişilmesini istemeyebiliyorsunuz. Bunu uygulama güvenliği için değil, geliştirme güvenliği amacıyla yapmak istiyorsunuz. Çünkü hangi veriyi değiştirmemeniz gerekeceğini zamanla unutacak ve değiştireceksiniz.</p>

<h3 id="kaynaklar">Kaynaklar</h3>

<p><a href="http://www.karalamalar.net/javascript-kapsam-ve-kaplamlari-anlamak/">[1] JavaScript Kapsam Ve Kaplamları Anlamak</a></p>

<p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36">[2] Master the JavaScript Interview: What is a Closure?</a></p>
:ET